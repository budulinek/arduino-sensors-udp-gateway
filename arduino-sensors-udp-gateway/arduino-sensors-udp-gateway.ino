/* Arduino-based sensor gateway

  Version history
  v0.9 2019-05-26 Initial commit, multiple 1-wire buses
  v1.0 2020-05-19 Add support for DHT sensors and light sensors
  v1.1 2020-11-02 Config file
  v1.2 2020-11-18 Better DHT sensors management
  v2.0 2021-02-22 Support for Pt100, Pt1000 RTD sensors, 
  v3.0 2023-XX-XX Add web interface, settings stored in EEPROM

*/

const byte VERSION[] = { 3, 0 };

#include <SPI.h>
#include <Ethernet.h>
#include <EthernetUdp.h>
#include <utility/w5100.h>
#include <CircularBuffer.h>  // CircularBuffer https://github.com/rlogiacco/CircularBuffer
#include <EEPROM.h>
#include <StreamLib.h>  // StreamLib https://github.com/jandrassy/StreamLib

#include "OneWireNg_CurrentPlatform.h"  // OneWireNg https://github.com/pstolarz/OneWireNg
#include "drivers/DSTherm.h"
#include "utils/Placeholder.h"


#include <BH1750FVI.h>  // BH1750FVI https://github.com/PeterEmbedded/BH1750FVI


// these are used by CreateTrulyRandomSeed() function
#include <avr/interrupt.h>
#include <avr/wdt.h>
#include <util/atomic.h>

#include "advanced_settings.h"

typedef struct {
  byte ip[4];
  byte subnet[4];
  byte gateway[4];
  byte dns[4];      // only used if ENABLE_DHCP
  bool enableDhcp;  // only used if ENABLE_DHCP
  byte remoteIp[4];
  bool udpBroadcast;
  uint16_t udpPort;
  uint16_t webPort;
  uint16_t owIntMin;                  // 1-wire sensors read min interval in seconds
  uint16_t owIntMax;                  // 1-wire sensors read max interval in seconds
  byte owChange;                      // reportable change
  uint16_t lightIntMin;               // light sensors read min interval in milliseconds
  uint16_t lightIntMax;               // light sensors read max interval in milliseconds
  byte lightChange;                   // reportable change
  byte owPins[OW_MAX_BUSES];          // pins of 1-wire buses
  byte lightPins[LIGHT_MAX_SENSORS];  // address pins for BH1750 sensors
} config_t;

const config_t DEFAULT_CONFIG = {
  DEFAULT_STATIC_IP,
  DEFAULT_SUBMASK,
  DEFAULT_GATEWAY,
  DEFAULT_DNS,
  DEFAULT_AUTO_IP,
  DEFAULT_REMOTE_IP,
  DEFAULT_BROADCAST,
  DEFAULT_UDP_PORT,
  DEFAULT_WEB_PORT,
  DEFAULT_OW_INT_MIN,
  DEFAULT_OW_INT_MAX,
  DEFAULT_OW_CHANGE,
  DEFAULT_LIGHT_INT_MIN,
  DEFAULT_LIGHT_INT_MAX,
  DEFAULT_LIGHT_CHANGE,
  {},  // 1-wire pins
  {},  // BH1750 address pins
};

typedef struct {
  byte owBus[OW_MAX_SENSORS];              // bus to which the sensor is attached
  byte owId[OW_MAX_SENSORS][8];            // IDs of 1-wire sensors
  bool lightConnected[LIGHT_MAX_SENSORS];  // connected BH1750 sensors
} sensors_t;

typedef struct {
  uint32_t eepromWrites;  // Number of Arduino EEPROM write cycles
  byte major;             // major version
  byte mac[6];            // MAC Address (initial value is random generated)
  config_t config;        // configuration values
  sensors_t sensors;      // sensors
} data_t;

data_t data;

// Keys for JSON elements, used in: 1) JSON documents, 2) ID of span tags, 3) Javascript.
enum type_type : byte {
  TYPE_1WIRE,  // 1-Wire
  TYPE_LIGHT,  // Light (BH1750FVI)
  TYPE_LAST,   // Must be the very last element in this array
};

#define FORCE_REPORT B10000000  // Force report when max interval is over
#define RESULT_SUCCESS B01000000
#define RESULT_SUCCESS_RETRY B00100000
#define RETRY_MASK B00001111  // Stores sensor retry attempts

/****** ETHERNET ******/

#ifdef UDP_TX_PACKET_MAX_SIZE
#undef UDP_TX_PACKET_MAX_SIZE
#define UDP_TX_PACKET_MAX_SIZE MODBUS_SIZE
#endif

byte maxSockNum = MAX_SOCK_NUM;

#ifdef ENABLE_DHCP
bool dhcpSuccess = false;
#endif /* ENABLE_DHCP */

EthernetUDP Udp;
EthernetServer webServer(DEFAULT_CONFIG.webPort);

/****** TIMERS AND STATE MACHINE ******/

class Timer {
private:
  uint32_t timestampLastHitMs;
  uint32_t sleepTimeMs;
public:
  boolean isOver();
  void sleep(uint32_t sleepTimeMs);
};
boolean Timer::isOver() {
  if ((uint32_t)(millis() - timestampLastHitMs) > sleepTimeMs) {
    return true;
  }
  return false;
}
void Timer::sleep(uint32_t sleepTimeMs) {
  this->sleepTimeMs = sleepTimeMs;
  timestampLastHitMs = millis();
}

Timer eepromTimer;  // timer to delay writing statistics to EEPROM

enum state_t : byte {
  STATE_IDLE,
  STATE_CONVERTING,
  STATE_FINISHED
};

/****** RUN TIME AND DATA COUNTERS ******/

volatile uint32_t seed1;  // seed1 is generated by CreateTrulyRandomSeed()
volatile int8_t nrot;
uint32_t seed2 = 17111989;  // seed2 is static


/****** SETUP: RUNS ONCE ******/

void setup() {

  // Serial.begin(115200);

  CreateTrulyRandomSeed();
  EEPROM.get(DATA_START, data);
  // is configuration already stored in EEPROM?
  if (data.major != VERSION[0]) {
    data.major = VERSION[0];
    // load default configuration from flash memory
    data.config = DEFAULT_CONFIG;
    generateMac();
    // set all pins to "None"
    memset(data.config.owPins, NUM_DIGITAL_PINS, sizeof(data.config.owPins));
    memset(data.config.lightPins, NUM_DIGITAL_PINS, sizeof(data.config.lightPins));
    resetSensors();
    updateEeprom();
  }
  startEthernet();

#ifdef ENABLE_ONEWIRE
  for (byte i = 0; i < OW_MAX_BUSES; i++) {
    startOneWire(i);
  }
#endif /* ENABLE_ONEWIRE */
#ifdef ENABLE_LIGHT
  Wire.begin();
  Wire.setWireTimeout(3000, true);  // I2C timeout to prevent lockups, latest Wire.h needed for this function.
  for (byte i = 0; i < LIGHT_MAX_SENSORS; i++) {
    startLight(i);
  }
#endif /* ENABLE_LIGHT */
}

/****** LOOP ******/

void loop() {

  // recvUdp();

#ifdef ENABLE_ONEWIRE
  for (byte i = 0; i < OW_MAX_BUSES; i++) {
    readOnewire(i);
  }
#endif /* ENABLE_ONEWIRE */

#ifdef ENABLE_LIGHT
  for (byte i = 0; i < LIGHT_MAX_SENSORS; i++) {
    readLight(i);
  }
#endif /* ENABLE_LIGHT */

  manageSockets();

#ifdef ENABLE_EXTENDED_WEBUI
  if (EEPROM_INTERVAL > 0 && eepromTimer.isOver() == true) {
    updateEeprom();
  }
#endif               /* ENABLE_EXTENDED_WEBUI */
#ifdef ENABLE_DHCP
  maintainDhcp();
#endif /* ENABLE_DHCP */
}
